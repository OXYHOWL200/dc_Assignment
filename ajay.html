<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Line Coding Virtual Laboratory</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: Arial, sans-serif;
      background-color: #f5d6d6;
    }
    .header {
      background-color: white;
      padding: 15px 30px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 4px solid #ff6600;
    }
    .header h1 {
      color: #4a90e2;
      font-size: 24px;
      font-weight: normal;
    }
    .logo {
      width: 50px;
      height: 50px;
      background-color: #4a4a8c;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
    }
    .nav-bar {
      background-color: #3d3d8c;
      display: flex;
      justify-content: center;
    }
    .nav-bar a {
      color: white;
      text-decoration: none;
      padding: 15px 25px;
      display: inline-block;
      transition: background-color 0.3s;
      cursor: pointer;
    }
    .nav-bar a:hover,
    .nav-bar a.active {
      background-color: #2d2d6c;
    }
    .container {
      max-width: 1400px;
      margin: 20px auto;
      padding: 20px;
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .block-diagram {
      background: white;
      padding: 30px;
      margin-bottom: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .block-diagram h2 {
      color: #3d3d8c;
      margin-bottom: 20px;
      text-align: center;
    }
    .diagram-container {
      position: relative;
      height: 400px;
      border: 2px solid #3d3d8c;
      border-radius: 5px;
      background: #f9f9f9;
      overflow: hidden;
    }
    .diagram-block {
      position: absolute;
      background: #3d3d8c;
      color: white;
      padding: 15px 30px;
      border-radius: 5px;
      font-weight: bold;
      cursor: move;
      user-select: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: box-shadow 0.3s;
    }
    .diagram-block:hover {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    .diagram-block.dragging {
      opacity: 0.7;
      z-index: 1000;
    }
    .connection-point {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #ff9966;
      border-radius: 50%;
      cursor: crosshair;
      border: 2px solid white;
      z-index: 10;
    }
    .connection-point.input {
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
    }
    .connection-point.output {
      right: -6px;
      top: 50%;
      transform: translateY(-50%);
    }
    .connection-point:hover {
      background: #ff6600;
      transform: translateY(-50%) scale(1.3);
    }
    .arrow-line {
      stroke: #ff9966;
      stroke-width: 3;
      fill: none;
      marker-end: url(#arrowhead);
    }
    .controls-info {
      margin-top: 15px;
      padding: 10px;
      background: #fff3e0;
      border-radius: 5px;
      border-left: 4px solid #ff9966;
    }
    .controls-info p {
      color: #3d3d8c;
      margin: 5px 0;
    }
    .reset-btn {
      margin-top: 15px;
      background: #ff6600;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
    }
    .reset-btn:hover {
      background: #e55500;
    }
    .oscilloscope {
      background: white;
      padding: 20px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    .scope-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 15px;
    }
    .input-section {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }
    .input-section label {
      font-weight: bold;
      color: #3d3d8c;
    }
    .input-section input {
      padding: 8px 15px;
      border: 2px solid #3d3d8c;
      border-radius: 4px;
      font-size: 14px;
      width: 200px;
    }
    .channel-selector {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .channel-btn {
      background: #3d3d8c;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.3s;
      font-size: 12px;
    }
    .channel-btn:hover {
      background: #2d2d6c;
    }
    .channel-btn.active {
      background: #4a90e2;
    }
    .scope-display {
      background: #000;
      min-height: 500px;
      border-radius: 5px;
      position: relative;
      margin-bottom: 20px;
    }
    #oscilloscope {
      width: 100%;
      height: 100%;
    }
    .controls-section {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .control-group {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    .control-group h3 {
      color: #3d3d8c;
      margin-bottom: 15px;
      font-size: 14px;
      text-align: center;
    }
    .dial-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .dial-svg {
      width: 180px;
      height: 180px;
      cursor: pointer;
      user-select: none;
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));
    }
    .value-display {
      text-align: center;
      color: #3d3d8c;
      font-weight: bold;
      margin-top: 10px;
      font-size: 16px;
    }
    .content-section {
      background: white;
      padding: 30px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }
    .content-section h2 {
      color: #3d3d8c;
      margin-bottom: 20px;
    }
    .content-section h3 {
      color: #3d3d8c;
      margin-top: 20px;
      margin-bottom: 10px;
    }
    .content-section p {
      color: #333;
      line-height: 1.6;
      margin-bottom: 15px;
    }
    .content-section ul, .content-section ol {
      margin-left: 30px;
      margin-bottom: 15px;
      color: #333;
      line-height: 1.8;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Line Coding Schemes - Virtual Laboratory</h1>
    <div class="logo">LOGO</div>
  </div>

  <div class="nav-bar">
    <a href="#" data-page="home" class="active">Home</a>
    <a href="#" data-page="aim">Aim</a>
    <a href="#" data-page="theory">Theory</a>
    <a href="#" data-page="procedure">Procedure</a>
    <a href="#" data-page="simulation">Simulation</a>
    <a href="#" data-page="results">Results</a>
  </div>

  <div class="container">
    <!-- Home Page -->
    <div class="page active" id="home">
      <div class="block-diagram">
        <h2>Interactive Block Diagram</h2>
        <div class="diagram-container" id="diagramContainer">
          <svg id="connectionSvg" style="position: absolute; width: 100%; height: 100%; pointer-events: none; z-index: 1;">
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                <polygon points="0 0, 10 3, 0 6" fill="#ff9966" />
              </marker>
            </defs>
          </svg>
          <div class="diagram-block" data-id="input" style="left: 50px; top: 170px;">
            Input Signal
            <div class="connection-point output" data-block="input" data-type="output"></div>
          </div>
          <div class="diagram-block" data-id="encoder" style="left: 350px; top: 170px;">
            Line Encoder
            <div class="connection-point input" data-block="encoder" data-type="input"></div>
            <div class="connection-point output" data-block="encoder" data-type="output"></div>
          </div>
          <div class="diagram-block" data-id="oscilloscope" style="left: 700px; top: 170px;">
            Virtual Oscilloscope
            <div class="connection-point input" data-block="oscilloscope" data-type="input"></div>
          </div>
        </div>
        <div class="controls-info">
          <p><strong>Instructions:</strong></p>
          <p>• Drag blocks to reposition them</p>
          <p>• Click and drag from orange output points (right) to input points (left) to create arrows</p>
          <p>• Click on arrows to delete them</p>
        </div>
        <button class="reset-btn" onclick="resetDiagram()">Reset Diagram</button>
      </div>
    </div>

    <!-- Aim Page -->
    <div class="page" id="aim">
      <div class="content-section">
        <h2>Aim of the Experiment</h2>
        <p>To study and analyze various line coding schemes used in digital communication systems including:</p>
        <ul>
          <li>Unipolar NRZ (Non-Return to Zero)</li>
          <li>Unipolar RZ (Return to Zero)</li>
          <li>Polar NRZ</li>
          <li>Polar RZ</li>
          <li>Bipolar AMI (Alternate Mark Inversion)</li>
          <li>Manchester Encoding</li>
          <li>Duo Binary Encoding</li>
          <li>HDB3 (High Density Bipolar of order 3)</li>
        </ul>
        <p>The experiment aims to help students:</p>
        <ul>
          <li>Understand the characteristics and properties of different line coding techniques</li>
          <li>Visualize the waveforms generated by each encoding scheme</li>
          <li>Compare advantages and disadvantages of various line coding methods</li>
          <li>Learn practical applications of line coding in digital communication systems</li>
        </ul>
      </div>
    </div>

    <!-- Theory Page -->
    <div class="page" id="theory">
      <div class="content-section">
        <h2>Theory</h2>
        
        <h3>Introduction to Line Coding</h3>
        <p><strong>Line Coding</strong> is the process of converting digital data (binary sequences of 0s and 1s) into digital signals suitable for transmission over a communication channel. The choice of line coding scheme affects bandwidth requirements, synchronization capability, error detection, and DC component of the signal.</p>
        
        <h3>Classification of Line Coding Schemes</h3>
        
        <h3>1. Unipolar NRZ (Non-Return to Zero)</h3>
        <p>In Unipolar NRZ, the signal uses only one polarity (positive voltage). Logic 1 is represented by a positive voltage (+V), and logic 0 is represented by zero voltage (0V). The signal does not return to zero between consecutive bits.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Simple implementation</li>
          <li>Presence of DC component</li>
          <li>No self-synchronization capability</li>
          <li>Baseline wander problem for long sequences of 0s or 1s</li>
        </ul>
        
        <h3>2. Unipolar RZ (Return to Zero)</h3>
        <p>Similar to Unipolar NRZ, but the signal returns to zero in the middle of each bit period. Logic 1 is represented by +V for the first half and 0V for the second half. Logic 0 remains at 0V throughout.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Better synchronization than NRZ due to transitions</li>
          <li>Requires more bandwidth (twice that of NRZ)</li>
          <li>Still has DC component issues</li>
        </ul>
        
        <h3>3. Polar NRZ</h3>
        <p>Uses both positive and negative voltage levels. Logic 1 is represented by +V and logic 0 by -V. This is more efficient than unipolar schemes.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Better noise immunity than unipolar</li>
          <li>No DC component for balanced data</li>
          <li>More power efficient</li>
          <li>Synchronization issues for long runs of same bit</li>
        </ul>
        
        <h3>4. Polar RZ</h3>
        <p>Combines the advantages of polar signaling with return-to-zero. Signal returns to zero in the middle of each bit period.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Better synchronization than Polar NRZ</li>
          <li>Requires twice the bandwidth</li>
          <li>Good noise immunity</li>
        </ul>
        
        <h3>5. Bipolar AMI (Alternate Mark Inversion)</h3>
        <p>Logic 0 is represented by zero voltage. Logic 1 alternates between +V and -V. Consecutive 1s have opposite polarity.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>No DC component</li>
          <li>Simple error detection (violation of alternation rule)</li>
          <li>Better bandwidth utilization</li>
          <li>Problem with long sequences of zeros</li>
        </ul>
        
        <h3>6. Manchester Encoding</h3>
        <p>Also known as bi-phase encoding. Logic 1 is represented by a transition from low to high in the middle of the bit period. Logic 0 is represented by a transition from high to low.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Excellent self-synchronization (transition in every bit)</li>
          <li>No DC component</li>
          <li>Used in Ethernet (10BASE-T)</li>
          <li>Requires twice the bandwidth</li>
        </ul>
        
        <h3>7. Duo Binary Encoding</h3>
        <p>A form of partial response signaling where the current bit value depends on the current input and previous encoded output. Uses correlation between adjacent bits.</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Better spectral efficiency</li>
          <li>Reduced intersymbol interference</li>
          <li>Three voltage levels</li>
        </ul>
        
        <h3>8. HDB3 (High Density Bipolar of order 3)</h3>
        <p>An improvement over AMI that prevents long sequences of zeros. When four consecutive zeros occur, they are replaced by a special code that includes a violation (same polarity as previous 1).</p>
        <p><strong>Characteristics:</strong></p>
        <ul>
          <li>Solves the long zero sequence problem of AMI</li>
          <li>Maintains synchronization</li>
          <li>No DC component</li>
          <li>Used in E1 carrier systems</li>
        </ul>
      </div>
    </div>

    <!-- Procedure Page -->
    <div class="page" id="procedure">
      <div class="content-section">
        <h2>Procedure</h2>
        
        <h3>Step 1: Understanding the Block Diagram</h3>
        <p>Navigate to the Home page to see the interactive block diagram showing the flow from Input Signal → Line Encoder → Virtual Oscilloscope. You can drag blocks and create connections between them.</p>
        
        <h3>Step 2: Access the Simulation</h3>
        <p>Click on the "Simulation" tab in the navigation bar to access the virtual oscilloscope interface.</p>
        
        <h3>Step 3: Enter Binary Input</h3>
        <p>In the "Binary Input" field, enter your desired binary sequence. For example: <strong>10110100</strong></p>
        <p>Ensure you only use 0s and 1s. The default sequence is already provided for testing.</p>
        
        <h3>Step 4: Generate the Signal</h3>
        <p>Click the "Generate" button to process your input and display it on the oscilloscope.</p>
        
        <h3>Step 5: Select Line Coding Scheme</h3>
        <p>Use the channel selector buttons to switch between different line coding schemes:</p>
        <ul>
          <li><strong>Input:</strong> Shows only the original digital input signal</li>
          <li><strong>Unipolar NRZ:</strong> View unipolar non-return-to-zero encoding</li>
          <li><strong>Unipolar RZ:</strong> View unipolar return-to-zero encoding</li>
          <li><strong>Polar NRZ:</strong> View polar non-return-to-zero encoding</li>
          <li><strong>Polar RZ:</strong> View polar return-to-zero encoding</li>
          <li><strong>Bipolar AMI:</strong> View alternate mark inversion encoding</li>
          <li><strong>Manchester:</strong> View Manchester encoding</li>
          <li><strong>Duo Binary:</strong> View duo binary encoding</li>
          <li><strong>HDB3:</strong> View HDB3 encoding</li>
        </ul>
        
        <h3>Step 6: Adjust Control Parameters</h3>
        <p>Use the two control dials to manipulate the display:</p>
        <ol>
          <li><strong>Bit Rate:</strong> Click and drag the dial to control how many bits are displayed on the screen (4 to 32 bits). The input pattern repeats to fill the screen.</li>
          <li><strong>Amplitude:</strong> Click and drag the dial to adjust the voltage level of the encoded signal (1V to 10V). Note: Input signal amplitude remains constant at 5V.</li>
        </ol>
        
        <h3>Step 7: Observe and Compare</h3>
        <p>Compare the characteristics of different encoding schemes by switching between channels. Notice:</p>
        <ul>
          <li>How each scheme represents the same binary data differently</li>
          <li>The number of voltage levels used</li>
          <li>The presence or absence of transitions</li>
          <li>The bandwidth requirements (RZ and Manchester use more transitions)</li>
        </ul>
        
        <h3>Step 8: Use Oscilloscope Tools</h3>
        <p>The oscilloscope display includes professional tools in the top-right corner:</p>
        <ul>
          <li>Download the plot as PNG image</li>
          <li>Zoom in/out to examine details</li>
          <li>Pan across the waveform</li>
          <li>Autoscale to fit the display</li>
          <li>Reset axes to default view</li>
        </ul>
        
        <h3>Step 9: Record Observations</h3>
        <p>Navigate to the "Results" page to document your findings and observations for each line coding scheme.</p>
      </div>
    </div>

    <!-- Simulation Page -->
    <div class="page" id="simulation">
      <div class="oscilloscope">
        <div class="scope-header">
          <div class="input-section">
            <label for="binaryInput">Binary Input:</label>
            <input type="text" id="binaryInput" placeholder="Enter binary (e.g., 10110100)" value="10110100">
            <button class="channel-btn" onclick="updateSignal()">Generate</button>
          </div>
          <div class="channel-selector">
            <button class="channel-btn active" onclick="selectChannel(0)">Input</button>
            <button class="channel-btn" onclick="selectChannel(1)">Unipolar NRZ</button>
            <button class="channel-btn" onclick="selectChannel(2)">Unipolar RZ</button>
            <button class="channel-btn" onclick="selectChannel(3)">Polar NRZ</button>
            <button class="channel-btn" onclick="selectChannel(4)">Polar RZ</button>
            <button class="channel-btn" onclick="selectChannel(5)">Bipolar AMI</button>
            <button class="channel-btn" onclick="selectChannel(6)">Manchester</button>
            <button class="channel-btn" onclick="selectChannel(7)">Duo Binary</button>
            <button class="channel-btn" onclick="selectChannel(8)">HDB3</button>
          </div>
        </div>

        <div class="scope-display">
          <div id="oscilloscope"></div>
        </div>

        <div class="controls-section">
          <div class="control-group">
            <h3>Bit Rate (bits shown)</h3>
            <div class="dial-container">
              <svg class="dial-svg" viewBox="0 0 200 200" id="bitRateDial">
                <!-- Outer rim -->
                <circle cx="100" cy="100" r="90" fill="none" stroke="#4a90e2" stroke-width="3"/>
                <!-- Main dial body -->
                <circle cx="100" cy="100" r="80" fill="url(#dialGradient)" stroke="#2d2d6c" stroke-width="2"/>
                <!-- Inner circle -->
                <circle cx="100" cy="100" r="65" fill="#0f0f17" stroke="#3d3d8c" stroke-width="2"/>
                <!-- Scale markers -->
                <line x1="100" y1="25" x2="100" y2="35" stroke="#888" stroke-width="2"/>
                <line x1="190" y1="100" x2="180" y2="100" stroke="#888" stroke-width="2"/>
                <line x1="10" y1="100" x2="20" y2="100" stroke="#888" stroke-width="2"/>
                <line x1="156" y1="44" x2="149" y2="51" stroke="#666" stroke-width="1.5"/>
                <line x1="44" y1="44" x2="51" y2="51" stroke="#666" stroke-width="1.5"/>
                <!-- Pointer with glow -->
                <line id="bitRatePointer" x1="100" y1="100" x2="100" y2="35" stroke="#ff9966" stroke-width="5" stroke-linecap="round" filter="url(#glow)"/>
                <circle cx="100" cy="100" r="12" fill="#ff6600" stroke="#ff9966" stroke-width="2"/>
                <!-- Value labels -->
                <text x="54" y="145" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">4</text>
                <text x="35" y="108" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">8</text>
                <text x="45" y="65" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">12</text>
                <text x="78" y="38" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">16</text>
                <text x="120" y="38" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">20</text>
                <text x="155" y="65" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">24</text>
                <text x="164" y="107" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">28</text>
                <text x="145" y="145" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">32</text>
                <text x="100" y="165" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">0</text>
                <defs>
                  <linearGradient id="dialGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#2d2d6c;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#1a1a4a;stop-opacity:1" />
                  </linearGradient>
                  <filter id="glow">
                    <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                    <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
              </svg>
              <div class="value-display" id="bitRateValue">8 bits</div>
            </div>
          </div>

          <div class="control-group">
            <h3>Amplitude</h3>
            <div class="dial-container">
              <svg class="dial-svg" viewBox="0 0 200 200" id="amplitudeDial">
                <!-- Outer rim -->
                <circle cx="100" cy="100" r="90" fill="none" stroke="#4a90e2" stroke-width="3"/>
                <!-- Main dial body -->
                <circle cx="100" cy="100" r="80" fill="url(#dialGradient2)" stroke="#2d2d6c" stroke-width="2"/>
                <!-- Inner circle -->
                <circle cx="100" cy="100" r="65" fill="#0f0f17" stroke="#3d3d8c" stroke-width="2"/>
                <!-- Scale markers -->
                <line x1="100" y1="25" x2="100" y2="35" stroke="#888" stroke-width="2"/>
                <line x1="190" y1="100" x2="180" y2="100" stroke="#888" stroke-width="2"/>
                <line x1="10" y1="100" x2="20" y2="100" stroke="#888" stroke-width="2"/>
                <line x1="156" y1="44" x2="149" y2="51" stroke="#666" stroke-width="1.5"/>
                <line x1="44" y1="44" x2="51" y2="51" stroke="#666" stroke-width="1.5"/>
                <!-- Pointer with glow -->
                <line id="amplitudePointer" x1="100" y1="100" x2="100" y2="35" stroke="#ff9966" stroke-width="5" stroke-linecap="round" filter="url(#glow2)"/>
                <circle cx="100" cy="100" r="12" fill="#ff6600" stroke="#ff9966" stroke-width="2"/>
                <!-- Value labels -->
                <text x="100" y="175" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">0V</text>
                <text x="54" y="145" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">1V</text>
                <text x="37" y="116" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">2V</text>
                <text x="37" y="83" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">3V</text>
                <text x="54" y="54" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">4V</text>
                <text x="83" y="37" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">5V</text>
                <text x="116" y="37" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">6V</text>
                <text x="145" y="54" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">7V</text>
                <text x="162" y="83" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">8V</text>
                <text x="162" y="116" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">9V</text>
                <text x="145" y="145" text-anchor="middle" fill="#ddd" font-size="14" font-weight="bold">10V</text>
                <defs>
                  <linearGradient id="dialGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#2d2d6c;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#1a1a4a;stop-opacity:1" />
                  </linearGradient>
                  <filter id="glow2">
                    <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                    <feMerge>
                      <feMergeNode in="coloredBlur"/>
                      <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                  </filter>
                </defs>
              </svg>
              <div class="value-display" id="amplitudeValue">5.0 V</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Results Page -->
    <div class="page" id="results">
      <div class="content-section">
        <h2>Results and Observations</h2>
        
        <h3>Experimental Data</h3>
        <p><strong>Binary Input Sequence:</strong> ___________________________</p>
        <p><strong>Date of Experiment:</strong> ___________________________</p>
        
        <h3>Observations for Each Line Coding Scheme</h3>
        
        <h3>1. Unipolar NRZ</h3>
        <p><strong>Voltage Levels Used:</strong> 0V and +V</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Uses only positive voltage levels</li>
          <li>Simple implementation</li>
          <li>Presence of DC component</li>
          <li>No synchronization for long sequences of same bit</li>
        </ul>
        
        <h3>2. Unipolar RZ</h3>
        <p><strong>Voltage Levels Used:</strong> 0V and +V (returns to 0)</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Signal returns to zero in middle of bit period</li>
          <li>Better synchronization than NRZ</li>
          <li>Requires double bandwidth</li>
        </ul>
        
        <h3>3. Polar NRZ</h3>
        <p><strong>Voltage Levels Used:</strong> +V and -V</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Uses both positive and negative voltages</li>
          <li>Better noise immunity than unipolar</li>
          <li>No DC component for balanced data</li>
          <li>More power efficient</li>
        </ul>
        
        <h3>4. Polar RZ</h3>
        <p><strong>Voltage Levels Used:</strong> +V, 0V, and -V</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Returns to zero between bits</li>
          <li>Good synchronization capability</li>
          <li>Higher bandwidth requirement</li>
        </ul>
        
        <h3>5. Bipolar AMI</h3>
        <p><strong>Voltage Levels Used:</strong> +V, 0V, and -V (alternating for 1s)</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Logic 1s alternate between positive and negative</li>
          <li>No DC component</li>
          <li>Simple error detection capability</li>
          <li>Problem with long sequences of zeros</li>
        </ul>
        
        <h3>6. Manchester Encoding</h3>
        <p><strong>Voltage Levels Used:</strong> +V and -V (with mid-bit transitions)</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Transition in middle of every bit period</li>
          <li>Excellent self-synchronization</li>
          <li>No DC component</li>
          <li>Requires double bandwidth</li>
          <li>Used in Ethernet networks</li>
        </ul>
        
        <h3>7. Duo Binary</h3>
        <p><strong>Voltage Levels Used:</strong> +V, 0V, and -V</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Uses correlation between adjacent bits</li>
          <li>Better spectral efficiency</li>
          <li>Three voltage levels</li>
        </ul>
        
        <h3>8. HDB3</h3>
        <p><strong>Voltage Levels Used:</strong> +V, 0V, and -V (with violation codes)</p>
        <p><strong>Observations:</strong></p>
        <ul>
          <li>Prevents long sequences of zeros</li>
          <li>Uses violation codes for four consecutive zeros</li>
          <li>Maintains synchronization</li>
          <li>No DC component</li>
          <li>Used in E1 telecommunication systems</li>
        </ul>
        
        <h3>Comparison Summary</h3>
        <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
          <thead>
            <tr style="background: #3d3d8c; color: white;">
              <th style="border: 1px solid #ddd; padding: 10px;">Scheme</th>
              <th style="border: 1px solid #ddd; padding: 10px;">DC Component</th>
              <th style="border: 1px solid #ddd; padding: 10px;">Synchronization</th>
              <th style="border: 1px solid #ddd; padding: 10px;">Bandwidth</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Unipolar NRZ</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Yes</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Poor</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Low</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Unipolar RZ</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Yes</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Good</td>
              <td style="border: 1px solid #ddd; padding: 8px;">High</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Polar NRZ</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Poor</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Low</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Polar RZ</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Good</td>
              <td style="border: 1px solid #ddd; padding: 8px;">High</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Bipolar AMI</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Poor</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Medium</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Manchester</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Excellent</td>
              <td style="border: 1px solid #ddd; padding: 8px;">High</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">Duo Binary</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Good</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Medium</td>
            </tr>
            <tr>
              <td style="border: 1px solid #ddd; padding: 8px;">HDB3</td>
              <td style="border: 1px solid #ddd; padding: 8px;">No</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Good</td>
              <td style="border: 1px solid #ddd; padding: 8px;">Medium</td>
            </tr>
          </tbody>
        </table>
        
        <h3>Conclusion</h3>
        <p>Successfully studied and analyzed various line coding schemes. Each scheme has its own advantages and applications in digital communication systems. The choice of line coding depends on factors like bandwidth availability, synchronization requirements, DC component tolerance, and error detection needs.</p>
      </div>
    </div>
  </div>

  <script>
    // Navigation between pages
    document.querySelectorAll('.nav-bar a').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const page = link.dataset.page;
        
        document.querySelectorAll('.nav-bar a').forEach(a => a.classList.remove('active'));
        link.classList.add('active');
        
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
        document.getElementById(page).classList.add('active');
        
        // If navigating to simulation, redraw oscilloscope
        if (page === 'simulation') {
          setTimeout(() => drawOscilloscope(), 100);
        }
      });
    });

    // Block Diagram Interactions
    let draggedBlock = null;
    let offsetX, offsetY;
    let connections = [];
    let isDrawing = false;
    let startPoint = null;
    let tempLine = null;

    const blocks = document.querySelectorAll('.diagram-block');
    const container = document.getElementById('diagramContainer');
    const svg = document.getElementById('connectionSvg');

    blocks.forEach(block => {
      block.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('connection-point')) return;
        
        draggedBlock = block;
        const rect = block.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;
        block.classList.add('dragging');
      });
    });

    document.addEventListener('mousemove', (e) => {
      if (draggedBlock) {
        const containerRect = container.getBoundingClientRect();
        let x = e.clientX - containerRect.left - offsetX;
        let y = e.clientY - containerRect.top - offsetY;
        
        x = Math.max(0, Math.min(x, container.offsetWidth - draggedBlock.offsetWidth));
        y = Math.max(0, Math.min(y, container.offsetHeight - draggedBlock.offsetHeight));
        
        draggedBlock.style.left = x + 'px';
        draggedBlock.style.top = y + 'px';
        
        updateConnections();
      }
      
      if (isDrawing && tempLine) {
        const containerRect = container.getBoundingClientRect();
        const x = e.clientX - containerRect.left;
        const y = e.clientY - containerRect.top;
        tempLine.setAttribute('x2', x);
        tempLine.setAttribute('y2', y);
      }
    });

    document.addEventListener('mouseup', () => {
      if (draggedBlock) {
        draggedBlock.classList.remove('dragging');
        draggedBlock = null;
      }
      
      if (tempLine && tempLine.parentNode) {
        tempLine.parentNode.removeChild(tempLine);
        tempLine = null;
      }
      isDrawing = false;
      startPoint = null;
    });

    document.querySelectorAll('.connection-point').forEach(point => {
      point.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        if (point.dataset.type !== 'output') return;
        
        const rect = point.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        startPoint = {
          x: rect.left + rect.width / 2 - containerRect.left,
          y: rect.top + rect.height / 2 - containerRect.top,
          block: point.dataset.block,
          type: point.dataset.type
        };
        
        isDrawing = true;
        tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        tempLine.setAttribute('class', 'arrow-line');
        tempLine.setAttribute('x1', startPoint.x);
        tempLine.setAttribute('y1', startPoint.y);
        tempLine.setAttribute('x2', startPoint.x);
        tempLine.setAttribute('y2', startPoint.y);
        svg.appendChild(tempLine);
      });
      
      point.addEventListener('mouseup', (e) => {
        if (isDrawing && startPoint && point.dataset.type === 'input') {
          e.stopPropagation();
          const rect = point.getBoundingClientRect();
          const containerRect = container.getBoundingClientRect();
          const endPoint = {
            x: rect.left + rect.width / 2 - containerRect.left,
            y: rect.top + rect.height / 2 - containerRect.top,
            block: point.dataset.block,
            type: point.dataset.type
          };
          
          if (startPoint.block !== endPoint.block) {
            connections.push({ start: startPoint, end: endPoint });
            updateConnections();
          }
          
          if (tempLine && tempLine.parentNode) {
            tempLine.parentNode.removeChild(tempLine);
            tempLine = null;
          }
          isDrawing = false;
          startPoint = null;
        }
      });
    });

    function updateConnections() {
      svg.querySelectorAll('.arrow-line:not([data-temp])').forEach(line => line.remove());
      
      connections.forEach((conn, index) => {
        const startBlock = document.querySelector(`[data-id="${conn.start.block}"]`);
        const endBlock = document.querySelector(`[data-id="${conn.end.block}"]`);
        
        if (!startBlock || !endBlock) return;
        
        const startPoint = getConnectionPointPosition(startBlock, conn.start.type);
        const endPoint = getConnectionPointPosition(endBlock, conn.end.type);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('class', 'arrow-line');
        line.setAttribute('x1', startPoint.x);
        line.setAttribute('y1', startPoint.y);
        line.setAttribute('x2', endPoint.x);
        line.setAttribute('y2', endPoint.y);
        line.style.cursor = 'pointer';
        line.dataset.index = index;
        
        line.addEventListener('click', () => {
          connections.splice(index, 1);
          updateConnections();
        });
        
        svg.appendChild(line);
      });
    }

    function getConnectionPointPosition(block, type) {
      const rect = block.getBoundingClientRect();
      const containerRect = container.getBoundingClientRect();
      const point = block.querySelector(`.connection-point.${type}`);
      const pointRect = point.getBoundingClientRect();
      
      return {
        x: pointRect.left + pointRect.width / 2 - containerRect.left,
        y: pointRect.top + pointRect.height / 2 - containerRect.top
      };
    }

    function resetDiagram() {
      connections = [];
      updateConnections();
      
      const positions = {
        input: { left: 50, top: 170 },
        encoder: { left: 350, top: 170 },
        oscilloscope: { left: 700, top: 170 }
      };
      
      blocks.forEach(block => {
        const id = block.dataset.id;
        block.style.left = positions[id].left + 'px';
        block.style.top = positions[id].top + 'px';
      });
    }

    // Line Coding Simulation
    let currentChannel = 0;
    let binaryInput = '10110100';
    
    let channelSettings = [];
    for (let i = 0; i < 9; i++) {
      channelSettings.push({
        bitsShown: 8,
        amplitude: 5
      });
    }

    function updateControlsDisplay() {
      const settings = channelSettings[currentChannel];
      
      updateDialPointer('bitRateDial', 'bitRatePointer', settings.bitsShown, 4, 32);
      document.getElementById('bitRateValue').textContent = settings.bitsShown + ' bits';
      
      updateDialPointer('amplitudeDial', 'amplitudePointer', settings.amplitude, 1, 10);
      document.getElementById('amplitudeValue').textContent = settings.amplitude.toFixed(1) + ' V';
    }

    function updateDialPointer(dialId, pointerId, value, min, max) {
      const pointer = document.getElementById(pointerId);
      const normalized = (value - min) / (max - min);
      // Map to -135° (left) through 0° (top) to +135° (right)
      const angle = -135 + (normalized * 270);
      const radians = (angle * Math.PI) / 180;
      const x2 = 100 + 65 * Math.sin(radians);
      const y2 = 100 - 65 * Math.cos(radians);
      pointer.setAttribute('x2', x2);
      pointer.setAttribute('y2', y2);
    }

    function setupDialInteraction(dialId, pointerId, min, max, step, callback) {
      const dial = document.getElementById(dialId);
      let isDragging = false;

      const updateFromMouse = (e) => {
        const rect = dial.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const dx = e.clientX - centerX;
        const dy = e.clientY - centerY;
        let angle = Math.atan2(dx, -dy) * (180 / Math.PI);
        
        // Constrain to -135° to +135° range (270° total sweep)
        if (angle < -135) angle = -135;
        if (angle > 135) angle = 135;
        
        // Convert angle to normalized value (0 to 1)
        const normalized = (angle + 135) / 270;
        
        // Calculate actual value
        let value = min + normalized * (max - min);
        
        // Round to nearest step
        value = Math.round(value / step) * step;
        
        // Clamp to range
        value = Math.max(min, Math.min(max, value));
        
        callback(value);
      };

      dial.addEventListener('mousedown', (e) => {
        isDragging = true;
        updateFromMouse(e);
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (isDragging) {
          updateFromMouse(e);
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Touch support
      dial.addEventListener('touchstart', (e) => {
        isDragging = true;
        const touch = e.touches[0];
        updateFromMouse(touch);
        e.preventDefault();
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (isDragging) {
          const touch = e.touches[0];
          updateFromMouse(touch);
          e.preventDefault();
        }
      }, { passive: false });

      document.addEventListener('touchend', () => {
        isDragging = false;
      });
    }

    function selectChannel(channel) {
      currentChannel = channel;
      const buttons = document.querySelectorAll('.channel-selector .channel-btn');
      buttons.forEach((btn, idx) => {
        btn.classList.toggle('active', idx === channel);
      });
      updateControlsDisplay();
      drawOscilloscope();
    }

    function updateSignal() {
      const input = document.getElementById('binaryInput').value;
      if (/^[01]+$/.test(input)) {
        binaryInput = input;
        drawOscilloscope();
      } else {
        alert('Please enter only 0s and 1s');
      }
    }

    function repeatPattern(pattern, totalBits) {
      let repeated = '';
      while (repeated.length < totalBits) {
        repeated += pattern;
      }
      return repeated.substring(0, totalBits);
    }

    function generateUnipolarNRZ(bits, amp) {
      const a = parseFloat(amp);
      return bits.split('').map(bit => bit === '1' ? a : 0);
    }

    function generateUnipolarRZ(bits, amp) {
      const a = parseFloat(amp);
      let signal = [];
      bits.split('').forEach(bit => {
        signal.push(bit === '1' ? a : 0);
        signal.push(0);
      });
      return signal;
    }

    function generatePolarNRZ(bits, amp) {
      const a = parseFloat(amp);
      return bits.split('').map(bit => bit === '1' ? a : -a);
    }

    function generatePolarRZ(bits, amp) {
      const a = parseFloat(amp);
      let signal = [];
      bits.split('').forEach(bit => {
        signal.push(bit === '1' ? a : -a);
        signal.push(0);
      });
      return signal;
    }

    function generateBipolarAMI(bits, amp) {
      const a = parseFloat(amp);
      let signal = [];
      let lastOne = a;
      bits.split('').forEach(bit => {
        if (bit === '1') {
          signal.push(lastOne);
          lastOne = -lastOne;
        } else {
          signal.push(0);
        }
      });
      return signal;
    }

    function generateManchester(bits, amp) {
      const a = parseFloat(amp);
      const signal = [];
      bits.split('').forEach(bit => {
        if (bit === '1') {
          signal.push(a);
          signal.push(-a);
        } else {
          signal.push(-a);
          signal.push(a);
        }
      });
      return signal;
    }

    function generateDuoBinary(bits, amp) {
      const a = parseFloat(amp);
      let signal = [];
      let prev = 0;
      bits.split('').forEach(bit => {
        if (bit === '1') {
          let val = prev === 0 ? a : -prev;
          signal.push(val);
          prev = val;
        } else {
          signal.push(0);
          prev = 0;
        }
      });
      return signal;
    }

    function generateHDB3(bits, amp) {
      const a = parseFloat(amp);
      const signal = [];
      let lastPolarity = -a;
      let nonZeroCount = 0;
      let zeroRun = 0;

      bits.split('').forEach(bit => {
        if (bit === '1') {
          const out = -lastPolarity;
          signal.push(out);
          lastPolarity = out;
          nonZeroCount++;
          zeroRun = 0;
        } else {
          signal.push(0);
          zeroRun++;

          if (zeroRun === 4) {
            const prevPolarity = lastPolarity;

            if (nonZeroCount % 2 === 1) {
              signal[signal.length - 1] = prevPolarity;
              lastPolarity = prevPolarity;
            } else {
              const BV = -prevPolarity;
              signal[signal.length - 4] = BV;
              signal[signal.length - 1] = BV;
              lastPolarity = BV;
            }

            nonZeroCount = 0;
            zeroRun = 0;
          }
        }
      });

      return signal;
    }

    function generateInputSignal(bits) {
      return bits.split('').map(bit => bit === '1' ? 5 : 0);
    }

    function createTimeArray(signal, bitsShown, xOffset = 0) {
      const totalSamples = Math.max(1, signal.length);
      const bits = Math.max(1, Math.round(bitsShown));
      let samplesPerBit = totalSamples / bits;
      samplesPerBit = Math.max(1, Math.round(samplesPerBit));
      const bitDuration = 1;
      const dt = bitDuration / samplesPerBit;

      const time = [];
      for (let i = 0; i < totalSamples; i++) {
        time.push(i * dt + xOffset);
      }
      return time;
    }

    function drawOscilloscope() {
      const settings = channelSettings[currentChannel];
      const bits = repeatPattern(binaryInput, settings.bitsShown);

      const inputSignal = generateInputSignal(bits);
      let encodedSignal = null;

      if (currentChannel !== 0) {
        switch (currentChannel) {
          case 1: encodedSignal = generateUnipolarNRZ(bits, settings.amplitude); break;
          case 2: encodedSignal = generateUnipolarRZ(bits, settings.amplitude); break;
          case 3: encodedSignal = generatePolarNRZ(bits, settings.amplitude); break;
          case 4: encodedSignal = generatePolarRZ(bits, settings.amplitude); break;
          case 5: encodedSignal = generateBipolarAMI(bits, settings.amplitude); break;
          case 6: encodedSignal = generateManchester(bits, settings.amplitude); break;
          case 7: encodedSignal = generateDuoBinary(bits, settings.amplitude); break;
          case 8: encodedSignal = generateHDB3(bits, settings.amplitude); break;
        }
      }

      const timeInput = createTimeArray(inputSignal, settings.bitsShown, 0);
      const timeOutput = encodedSignal ? createTimeArray(encodedSignal, settings.bitsShown, 0) : timeInput;

      const traces = [];

      traces.push({
        x: timeInput,
        y: inputSignal,
        type: 'scatter',
        mode: 'lines',
        line: { color: '#4a9eff', width: 2.5, shape: 'hv' },
        name: 'Input (Vi)',
        xaxis: 'x',
        yaxis: 'y'
      });

      traces.push({
        x: timeOutput,
        y: encodedSignal || inputSignal,
        type: 'scatter',
        mode: 'lines',
        line: { color: '#ff9933', width: 2.5, shape: 'hv' },
        name: currentChannel === 0 ? 'Input (Vi)' : 'Output (Vo)',
        xaxis: 'x',
        yaxis: 'y2'
      });

      // Fixed axis ranges instead of auto-scaling
      const layout = {
        paper_bgcolor: '#0f0f17',
        plot_bgcolor: '#0f0f17',
        margin: { l: 65, r: 20, t: 30, b: 40 },

        xaxis: {
          title: 'Time (s)',
          showgrid: true,
          gridcolor: '#222',
          zerolinecolor: '#555',
          color: '#aaa',
          domain: [0.08, 0.98],
          anchor: 'y'
        },

        yaxis: {
          title: 'Vi (V)',
          domain: [0.55, 1.00],
          range: [-1, 6],
          showgrid: true,
          gridcolor: '#333',
          zerolinecolor: '#777',
          color: '#9ec7ff',
          tickfont: { color: '#9ec7ff' },
          titlefont: { color: '#9ec7ff' }
        },

        yaxis2: {
          title: 'Vo (V)',
          domain: [0.05, 0.50],
          range: [-12, 12],
          showgrid: true,
          gridcolor: '#333',
          zerolinecolor: '#777',
          color: '#ffbf80',
          tickfont: { color: '#ffbf80' },
          titlefont: { color: '#ffbf80' },
          anchor: 'x'
        },

        showlegend: true,
        legend: { x: 0.98, y: 1.02, xanchor: 'right', font: { color: '#ddd' } },
        title: { text: 'Oscilloscope (upper: Input, lower: Output)', font: { color: '#ddd', size: 16 } }
      };

      const annotations = [];
      for (let i = 0; i < settings.bitsShown; i++) {
        annotations.push({
          x: i + 0.5,
          y: 1.0,
          xref: 'x',
          yref: 'paper',
          text: String(bits[i]),
          showarrow: false,
          font: { color: '#ccc', size: 12, family: 'monospace' }
        });
      }

      const shapes = [];
      const vlineColor = '#888';
      for (let i = 0; i <= settings.bitsShown; i++) {
        shapes.push({
          type: 'line',
          x0: i,
          x1: i,
          xref: 'x',
          y0: 0,
          y1: 1,
          yref: 'paper',
          line: {
            color: vlineColor,
            width: 1,
            dash: 'dot'
          }
        });
      }

      if (encodedSignal) {
        const arrowColor = '#ffeb3b';

        // Manchester transitions
        if (currentChannel === 6 && encodedSignal.length === settings.bitsShown * 2) {
          for (let i = 0; i < settings.bitsShown; i++) {
            const first = encodedSignal[2 * i];
            const second = encodedSignal[2 * i + 1];
            if (first === 0 || second === 0) continue;
            const arrowSymbol = first > second ? '↓' : '↑';
            const xPos = i + 0.5;
            const yPos = (first + second) / 2;
            annotations.push({
              x: xPos,
              y: yPos,
              xref: 'x',
              yref: 'y2',
              text: arrowSymbol,
              showarrow: false,
              font: { color: arrowColor, size: 20, family: 'monospace' },
              align: 'center'
            });
          }
        }

        // Polar RZ transitions
        if (currentChannel === 4 && encodedSignal.length === settings.bitsShown * 2) {
          for (let i = 0; i < settings.bitsShown; i++) {
            const first = encodedSignal[2 * i];
            const second = encodedSignal[2 * i + 1];
            if (first !== 0 && second === 0) {
              const arrowSymbol = first > second ? '↓' : '↑';
              const xPos = i + 0.5;
              const yPos = (first + second) / 2;
              annotations.push({
                x: xPos,
                y: yPos,
                xref: 'x',
                yref: 'y2',
                text: arrowSymbol,
                showarrow: false,
                font: { color: arrowColor, size: 18, family: 'monospace' },
                align: 'center'
              });
            }
          }
        }

        // Bipolar AMI transitions
        if (currentChannel === 5) {
          for (let i = 0; i < encodedSignal.length - 1; i++) {
            const left = encodedSignal[i];
            const right = encodedSignal[i + 1];
            // Show arrow on any transition
            if (left !== right) {
              const arrowSymbol = left > right ? '↓' : '↑';
              const bitIndex = Math.floor(i / 1); // Each bit is 1 sample in AMI
              const xPos = bitIndex + 1; // Place at transition point
              const yPos = (left + right) / 2;
              annotations.push({
                x: xPos,
                y: yPos,
                xref: 'x',
                yref: 'y2',
                text: arrowSymbol,
                showarrow: false,
                font: { color: arrowColor, size: 18, family: 'monospace' },
                align: 'center'
              });
            }
          }
        }

        // Polar NRZ and HDB3 transitions
        if ([3, 8].includes(currentChannel)) {
          for (let i = 0; i < encodedSignal.length - 1; i++) {
            const left = encodedSignal[i];
            const right = encodedSignal[i + 1];
            // Show arrow on any transition
            if (left !== right) {
              const arrowSymbol = left > right ? '↓' : '↑';
              const xPos = i + 1; // Place at transition point
              const yPos = (left + right) / 2;
              annotations.push({
                x: xPos,
                y: yPos,
                xref: 'x',
                yref: 'y2',
                text: arrowSymbol,
                showarrow: false,
                font: { color: arrowColor, size: 18, family: 'monospace' },
                align: 'center'
              });
            }
          }
        }
      }

      layout.shapes = shapes;
      layout.annotations = annotations;

      const config = { displayModeBar: true, responsive: true };

      Plotly.newPlot('oscilloscope', traces, layout, config);
    }

    // Setup dial interactions
    setupDialInteraction('bitRateDial', 'bitRatePointer', 4, 32, 1, (value) => {
      channelSettings[currentChannel].bitsShown = value;
      document.getElementById('bitRateValue').textContent = value + ' bits';
      updateDialPointer('bitRateDial', 'bitRatePointer', value, 4, 32);
      drawOscilloscope();
    });

    setupDialInteraction('amplitudeDial', 'amplitudePointer', 1, 10, 1, (value) => {
      channelSettings[currentChannel].amplitude = value;
      document.getElementById('amplitudeValue').textContent = value.toFixed(1) + ' V';
      updateDialPointer('amplitudeDial', 'amplitudePointer', value, 1, 10);
      drawOscilloscope();
    });

    // Initialize on load
    updateControlsDisplay();
    drawOscilloscope();
  </script>
</body>
</html>